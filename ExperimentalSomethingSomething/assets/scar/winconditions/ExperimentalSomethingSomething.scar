-----------------------------------------------------------------------
-- Imported Scripts
-----------------------------------------------------------------------

-- Import Utility Scripts
import("cardinal.scar")							-- Contains sfx references, UI templates, and Civ/Age helper functions
import("ScarUtil.scar")							-- Contains game helper functions

-- Import Gameplay Systems
import("gameplay/score.scar")					-- Tracks player score
import("gameplay/diplomacy.scar")				-- Manages Tribute

-- Import Win Conditions
import("winconditions/annihilation.scar")		-- Support for eliminating a player when they can no longer fight or produce units
import("winconditions/elimination.scar")		-- Support for player quitting or dropping (through pause menu or disconnection)
import("winconditions/surrender.scar")			-- Support for player surrender (through pause menu)

-- Import UI Support
import("gameplay/chi/current_dynasty_ui.scar")	-- Displays Chinese Dynasty UI
import("gameplay/event_cues.scar")
import("gameplay/currentageui.scar")

-----------------------------------------------------------------------
-- Data
-----------------------------------------------------------------------

-- Global data table that can be referenced in script functions (e.g. _mod.module = "Mod")
_mod = {
	module = "Mod",
	burnBuildingsMapIconIds = {}
}

-- Register the win condition (Some functions can be prepended with "Mod_" to be called automatically as part of the scripting framework)
Core_RegisterModule(_mod.module)

-----------------------------------------------------------------------
-- Scripting framework 
-----------------------------------------------------------------------

-- Called during load as part of the game setup sequence
function Mod_OnGameSetup()
	
	
	
end

-- Called before initialization, preceding other module OnInit functions
function Mod_PreInit()

end

-- Called on match initialization before handing control to the player
function Mod_OnInit()
	
	
	
end

-- Called after initialization is done when game is fading up from black
function Mod_Start()
	FOW_RevealAll()
	Network_RegisterEvent("Mod_InterpretCommand")
	
	local localPlayer = Game_GetLocalPlayer()
	local playerSlotIndex = Player_GetSlotIndex(localPlayer)
	
	if playerSlotIndex == 1 then
		Rule_AddInterval(Mod_PublishPollResult, 10)
	end
end


function Mod_PublishPollResult()
	local filePath = "C:/aoe4ti/poll_result.scar"
	local func = assert(loadfile(filePath))
	local command = func()
	
	Network_CallEvent("Mod_InterpretCommand", command)
end


function Mod_GetPlayerByName(playerName)
	for _, player in pairs(PLAYERS) do
		local temp = player.playerName.LocString
		if player.playerName.LocString == playerName then
			return player
		end
	end
	return nil
end


function Mod_GetLowestScoreAlivePlayer(excludePlayerId)
	local lowestScorePlayer
	for _, player in pairs(PLAYERS) do
		if player.id ~= excludePlayerId and not Core_IsPlayerEliminated(player.id) then
			if lowestScorePlayer == nil then
				lowestScorePlayer = player
			elseif player.score < lowestScorePlayer.score then
				lowestScorePlayer = player
			end
		end
	end
	
	return lowestScorePlayer
end


function Mod_InterpretCommand(sender_player_id, command)
	local splitCommand = {}
	for part in string.gmatch(command, '([^,]+)') do
		splitCommand[#splitCommand + 1] = part
	end
	
	local action = splitCommand[1]
	local playerName = splitCommand[2]
	local player = Mod_GetPlayerByName(playerName)
	
	if player == nil then
		print("Couldn't find player with name", playerName)
		return
	end
	
	if action == "send 1000g" then
		Player_AddResource(player.id, 3, 1000)
		Mod_SendEventNotificationToPlayers("Sent 1000g to " .. playerName)
	elseif action == "send wolves" then
		Mod_HandleSpawnWolves(player)
		Mod_SendEventNotificationToPlayers("Sent wolves to " .. playerName)
	elseif action == "send sheep" then
		Mod_HandleSpawnSheep(player)
		Mod_SendEventNotificationToPlayers("Sent sheep to " .. playerName)
	elseif action == "send photon man" then
		Mod_HandleSpawnPhotonMan(player)
		Mod_SendEventNotificationToPlayers("Sent photon man to " .. playerName)
	elseif action == "send great bombards" then
		Mod_HandleSpawnGreatBombards(player)
		Mod_SendEventNotificationToPlayers("Sent great bombards to" .. playerName)
	elseif action == "take stuff from and give to lowest score player" then
		Mod_HandleConvertUnitsToNextLowestScorePlayer(player)
		Mod_SendEventNotificationToPlayers("Took stuff from " .. playerName .. " and gave it to the next lowest score player")
	elseif action == "send tower elephants" then
		Mod_HandleSpawnTowerElephants(player)
		Mod_SendEventNotificationToPlayers("Sent tower elephants to " .. playerName)
	elseif action == "delete houses" then
		Mod_HandleDeleteHouses(player)
		Mod_SendEventNotificationToPlayers("Deleted some houses from " .. playerName)
	elseif action == "delete gers" then
		Mod_HandleDeleteGers(player)
		Mod_SendEventNotificationToPlayers("Deleted some gers from " .. playerName)
	elseif action == "delete mining camps" then
		Mod_HandleDeleteMiningCamps(player)
		Mod_SendEventNotificationToPlayers("Deleted some mining camps from " .. playerName)
	elseif action == "buff villagers" then
		Mod_HandleBuffVillagers(player)
		Mod_SendEventNotificationToPlayers("Buffing villagers for " .. playerName)
	elseif action == "villagers wander off" then
		Mod_HandleVillagersWanderOff(player)
		Mod_SendEventNotificationToPlayers("Villagers will wander off for " .. playerName)
	elseif action == "burn buildings" then
		Mod_HandleBurnBuildings(player)
		Mod_SendEventNotificationToPlayers("Set buildings on fire for " .. playerName)
	end
end


function Mod_HandleBurnBuildings(player)
	local building_egroup = Player_GetAllEntities(player.id)
	EGroup_Filter(building_egroup, "building", FILTER_KEEP)
	local buildingCount = EGroup_Count(building_egroup)
	
	local index = World_GetRand(1, buildingCount)
	local centralBuilding = EGroup_GetEntityAt(building_egroup, index)
	local center = Entity_GetPosition(centralBuilding)
	
	local numBuildingsToSetOnFire = Mod_CalculateNumUnits(1, 0.25)
	local tileSize = 4.5	-- TODO: double check this, probably wrong
	local radius = tileSize * Mod_CalculateNumUnits(1, 1)
	
	local mapIconId = MapIcon_CreatePosition(
		center,
		"icons\\minimap\\trade_route_enemy",
		1,
		255, 
		255,
		255,
		0
	)
	
	for i=1,buildingCount,1 do
		if i > numBuildingsToSetOnFire then
			return
		end
		
		local building = EGroup_GetEntityAt(building_egroup, i)
		local distance = Util_GetDistance(centralBuilding, building)
		local isBurnable = Entity_IsBurnable(building)
		
		if isBurnable and distance < radius then
			local burnThreshold = Entity_GetOnFireHealthPercentThreshold(building)
			Entity_SetHealth(building, burnThreshold)
		end
	end
	
	_mod.burnBuildingsMapIconIds[#_mod.burnBuildingsMapIconIds+1] = mapIconId
	
	Rule_AddOneShot(Mod_RemoveMapIcon, 15, removeIconArgs)
end


function Mod_RemoveMapIcon()
	local iconId = _mod.burnBuildingsMapIconIds[1]
	table.remove(_mod.burnBuildingsMapIconIds, 1)
	MapIcon_Destroy(iconId)
	Rule_RemoveMe()
end


function Mod_HandleVillagersWanderOff(player)
	local player_entgroupobs = Player_GetAllEntities(player.id)
	EGroup_Filter(player_entgroupobs, "worker", FILTER_KEEP)
	local eGroupCount = EGroup_Count(player_entgroupobs)
	local maxX = math.floor(World_GetWidth() / 2)
	local minX = -maxX
	
	local maxZ = math.floor(World_GetLength() / 2)
	local minZ = -maxZ
	
	for i=1,eGroupCount,1 do
		local entity = EGroup_GetEntityAt(player_entgroupobs, i)
		local squad = Entity_GetSquad(entity)
		
		local randX = World_GetRand(minX, maxX)
		local randZ = World_GetRand(minZ, maxZ)
		local randY = World_GetHeightAt(randX, randZ)
		
		local pos = World_Pos(randX, randY, randZ)
		
		local sgroup = SGroup_Create("some_vill")
		SGroup_Add(sgroup, squad)
		
		Cmd_AttackMove(sgroup, pos)
		
		SGroup_Destroy("some_vill")
	end
end


function Mod_HandleBuffVillagers(player)
	local player_entgroupobs = Player_GetAllEntities(player.id)
	EGroup_Filter(player_entgroupobs, "worker", FILTER_KEEP)
	
	Modify_EntityMaxHealth(player_entgroupobs, 75, MUT_Addition)
	Mod_Modify_WeaponDamage(player_entgroupobs, "hardpoint_01", 6, MUT_Addition)
end


function Mod_Modify_WeaponDamage(groupid, hardpoint, factor, usage)
	-- create the appropriate modifier
	local modifier = Modifier_Create(MAT_Weapon, "damage_weapon_modifier", usage, false, factor, hardpoint)
	local result = {}
	
	local _ApplyModifierToSquad = function(gid, idx, sid)
		if Squad_IsAlive(sid) and Squad_Count(sid) > 0 and Squad_HasWeaponHardpoint(sid, hardpoint) then
			local modids = Modifier_ApplyToSquad(modifier, sid, 0)
			table.insert(result, modids)
			Modifier_AddToSquadTable(sid, modids)
		end
	end
	
	local _ApplyModifierToEntity = function(gid, idx, eid)
		if Entity_IsAlive(eid) then
			local modids = Modifier_ApplyToEntity(modifier, eid, 0)
			table.insert(result, modids)
			Modifier_AddToEntityTable(eid, modids)
		end
	end
	
	if (scartype(groupid) == ST_SGROUP) then
		-- apply this to each squad in the group
		SGroup_ForEachEx(groupid, _ApplyModifierToSquad, true, true)
	elseif (scartype(groupid) == ST_EGROUP) then
		-- apply this to each entity in the group
		EGroup_ForEachEx(groupid, _ApplyModifierToEntity, true, true)
	end
	
	return result
	
end


function Mod_HandleDeleteMiningCamps(player)
	local numMiningCamps = Mod_CalculateNumUnits(1, 0.1)
	Mod_HandleDeleteEntities(player, {"mining_camp"}, numMiningCamps, {})
end


function Mod_HandleDeleteGers(player)
	local numHouses = Mod_CalculateNumUnits(1, 0.1)
	Mod_HandleDeleteEntities(player, {"ger"}, numHouses, {})
end


function Mod_HandleDeleteHouses(player)
	local numHouses = Mod_CalculateNumUnits(1, 0.1)
	Mod_HandleDeleteEntities(player, {"house"}, numHouses, {"ger"})
end


function Mod_HandleDeleteEntities(player, keepFilters, numEntities, removeFilters)
	local player_entgroupobs = Player_GetAllEntities(player.id)
	
	for _, filter in ipairs(keepFilters) do
		EGroup_Filter(player_entgroupobs, filter, FILTER_KEEP)
	end
	
	for _, filter in ipairs(removeFilters) do
		EGroup_Filter(player_entgroupobs, filter, FILTER_REMOVE)
	end
	
	local eGroupCount = EGroup_Count(player_entgroupobs)
	
	for i=1,numEntities,1 do
		if i > eGroupCount then
			return
		end
		
		local index = World_GetRand(1, eGroupCount)
		local entity = EGroup_GetEntityAt(player_entgroupobs, index)
		
		Entity_Kill(entity)
	end
end


function Mod_HandleConvertUnitsToNextLowestScorePlayer(player)
	local lowestScorePlayer = Mod_GetLowestScoreAlivePlayer(player.id)
	local player_entgroupobs = Player_GetAllEntities(player.id)
	local numUnits = Mod_CalculateNumUnits(1, 0.5)
	
	EGroup_Filter(player_entgroupobs, "landmark", FILTER_REMOVE)
	EGroup_Filter(player_entgroupobs, "building", FILTER_REMOVE)
	
	local eGroupCount = EGroup_Count(player_entgroupobs)
	
	for i=1,numUnits,1 do
		if i > eGroupCount then
			return
		end
		
		local index = World_GetRand(1, eGroupCount)
		local entity = EGroup_GetEntityAt(player_entgroupobs, index)
		local squad = Entity_GetSquad(entity)
		
		Util_SetPlayerOwner(entity, lowestScorePlayer.id)
		
		if squad ~= nil then
			Util_SetPlayerOwner(squad, lowestScorePlayer.id)
		end
	end
end


function Mod_HandleSpawnTowerElephants(player)
	Mod_HandleSpawnUnitsOnPlayersTc(player, "unit_war_elephant_tower2_4_sul", Mod_CalculateNumUnits(1, 0.25))
end


function Mod_HandleSpawnGreatBombards(player)
	Mod_HandleSpawnUnitsOnPlayersTc(player, "unit_bombard_4_ott", Mod_CalculateNumUnits(1, 0.25))
end


function Mod_HandleSpawnPhotonMan(player)
	Mod_HandleSpawnUnitsOnPlayersTc(player, "unit_photon_man", 1)
end


function Mod_HandleSpawnSheep(player)
	Mod_HandleSpawnUnitsOnPlayersVillagers(player, "gaia_herdable_sheep", Mod_CalculateNumUnits(1, 1))
end


function Mod_HandleSpawnWolves(player)
	Mod_HandleSpawnUnitsOnPlayersVillagers(player, "gaia_huntable_wolf", Mod_CalculateNumUnits(1, 1))
end


function Mod_HandleSpawnUnitsOnPlayersTc(player, blueprint, numUnits)
	Mod_HandleSpawnUnitsOnPlayersEntities(
		player,
		blueprint,
		"town_center",
		numUnits
	)
end

function Mod_HandleSpawnUnitsOnPlayersVillagers(player, blueprint, numUnits)
	Mod_HandleSpawnUnitsOnPlayersEntities(
		player,
		blueprint,
		"worker",
		numUnits
	)
end


function Mod_HandleSpawnUnitsOnPlayersEntities(player, blueprint, entityBpToSpawnOn, numUnits)
	local player_entgroupobs = Player_GetAllEntities(player.id)
	EGroup_Filter(player_entgroupobs, "worker", FILTER_KEEP)
	
	for i=1,EGroup_Count(player_entgroupobs),1 do
		local entity = EGroup_GetEntityAt(player_entgroupobs, i)
		
		local sbp = BP_GetSquadBlueprint(blueprint)

		local spawn_position = Entity_GetPosition(entity)
		local sg = SGroup_CreateIfNotFound("some_sg")
		UnitEntry_DeploySquads(player.id, sg, {{sbp = sbp, numSquads = 1 }}, spawn_position)
		
		if numUnits ~= nil and i >= numUnits then
			return
		end
	end
end


function Mod_CalculateNumUnits(intercept, slope)
	local gameTimeMins = World_GetGameTime() / 60.0
	local numUnits = math.floor(slope * gameTimeMins + intercept)
	
	return numUnits
end


function Mod_SendEventNotificationToPlayers(notificationText)
	local colour = {
		r = 255,
		g = 255,
		b = 255,
		a = 255
	}
	
	UI_CreateEventCueClickable(
		-1, 
		10.0,
		0, 
		20.0, 
		LOC(notificationText), 
		Loc_Empty(), 
		"high_priority", 
		"", 
		"sfx_ui_event_queue_high_priority_play", 
		colour.r, 
		colour.g, 
		colour.b, 
		colour.a, 
		ECV_Queue, 
		nothing
	)
end
